module Main where

import Control.Monad (guard)
import Control.Monad.Trans
import           Data.Text (Text)
import qualified Data.Text    as T
import qualified Data.Text.IO as T (readFile)
import Test.Tasty hiding (defaultMain)
import Test.Tasty.Golden.Advanced
import Test.Tasty.Golden.Manage
import System.IO
import qualified System.IO.Strict as Strict (readFile)
import System.Process
import System.Exit
import System.FilePath

invokeR :: FilePath -> IO Text
invokeR fp = do
    inh <- openFile fp ReadMode
    (_, Just outh, _, _) <- createProcess $ (proc "R" ["--vanilla","--silent","--slave"])
      { std_out = CreatePipe
      , std_in = UseHandle inh
      }
    T.pack <$> hGetContents outh

invokeH :: FilePath -> IO Text
invokeH fp = do
    -- Logic:
    --
    --    1. Run translation process that will output translation result to the
    --    pipe.
    --
    --    XXX: in general case when multifile translation will be enabled we
    --    will have to use files that were generated by H
    --
    --    2. Save file to the temporary module
    --
    --    3. Call ghci on resulting file
    --
    (_, Just outh1, _, _) <- createProcess $ (proc "./dist/build/H/H" ["--ghci",fp])
      { std_out = CreatePipe }
    (_, Just outh2, _, _) <- createProcess $ (proc "sh" ["tests/ghciH.sh","-v0","-ghci-script","H.ghci"])
      { std_out = CreatePipe
      , std_in = UseHandle outh1}
    T.pack <$> hGetContents outh2

invokeGHCi :: FilePath -> IO Text
invokeGHCi fp = fmap T.pack $ do
    (ecode, out, err) <- Strict.readFile fp >>= readProcessWithExitCode "sh" ["tests/ghciH.sh","-v0","-ghci-script","H.ghci"]
    return $ if ecode == ExitSuccess
             then out
             else out ++ err

scriptCase :: TestName
           -> FilePath
           -> TestTree
scriptCase name scriptPath =
    goldenTest
      name
      (invokeR scriptPath)
      (invokeH scriptPath)
      (\outputR outputH -> return $ do
         let a = T.lines outputR
             b = T.lines outputH
         -- Continue only if values don't match. If they do, then there's
         -- 'Nothing' to do...
         guard $ not $ and (zipWith compareValues a b) && Prelude.length a == Prelude.length b
         return $ unlines ["Outputs don't match."
                          , "R: "
                          , T.unpack outputR
                          , "H: "
                          , T.unpack outputH
                          ])
      (const $ return ())
  where
    -- Compare Haskell and R outputs:
    -- This function assumes that output is a vector string
    --    INFO Value1 Value2 .. ValueN
    -- where INFO is [OFFSET]. For decimals we are checking if
    -- they are equal with epsilon 1e-6, this is done because R
    -- output is not very predictable it can output up to 6
    -- characters or round them.
    compareValues :: Text -> Text -> Bool
    compareValues rO h =
      let (r': rs') = T.words rO
          (h': hs') = T.words h
      in (r' == h') && (all eqEpsilon $ zip (map (read . T.unpack) rs' :: [Double]) (map (read . T.unpack) hs' :: [Double]))
    eqEpsilon :: (Double, Double) -> Bool
    eqEpsilon (a, b) = (a - b < 1e-6) && (a - b > (-1e-6))

ghciSession :: TestName -> FilePath -> TestTree
ghciSession name scriptPath =
    goldenTest
      name
      (liftIO $ T.readFile $ scriptPath ++ ".golden.output")
      (invokeGHCi scriptPath)
      (\goldenOutput outputH ->
         let a = T.replace "\r\n" "\n" goldenOutput
             b = T.replace "\r\n" "\n" outputH
         in if T.words a == T.words b
            then return Nothing
            else return $ Just $
              unlines ["Outputs don't match."
                      , "expected: "
                      , T.unpack a
                      , ""
                      , Prelude.show $ T.unpack a
                      , ""
                      , "H: "
                      , T.unpack b
                      , ""
                      , Prelude.show $ T.unpack b
                      ])
      (const $ return ())

tests :: TestTree
tests = testGroup "Integration tests"
  [ ghciSession "qq.ghci" $
       "tests" </> "ghci" </> "qq.ghci"
  , ghciSession "qq-stderr.ghci" $
       "tests" </> "ghci" </> "qq-stderr.ghci"
  -- , scriptCase "Functions - factorial" $
  --     "tests" </> "R" </> "fact.R"
  -- , scriptCase "Functions - Fibonacci sequence" $
  --     "tests" </> "R" </> "fib.R"
  ]

main :: IO ()
main = do
    _ <- R.initialize R.defaultConfig
    defaultMain tests
